(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{443:function(e,t,a){"use strict";a.r(t);var n=a(1),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("blockquote",[a("p",[e._v("本文转载自："),a("a",{attrs:{href:"https://www.cnblogs.com/candy-xia/p/11425357.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue 页面回退mounted函数不执行的问题及解决方法"),a("OutboundLink")],1)])]),e._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#前言"}},[e._v("前言")])]),a("li",[a("a",{attrs:{href:"#原理"}},[e._v("原理")])]),a("li",[a("a",{attrs:{href:"#html结构"}},[e._v("html结构")])]),a("li",[a("a",{attrs:{href:"#js部分-vue生命周期"}},[e._v("js部分--vue生命周期")])]),a("li",[a("a",{attrs:{href:"#总结"}},[e._v("总结")])])])]),a("p"),e._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),a("p",[e._v("最近做项目碰到一个很头大的问题--从a页面跳到b页面进行编辑，编辑完再返回a页面，却没走a页面的钩子函数mounted，数据没有更新")]),e._v(" "),a("p",[e._v("经过一番面向百度研究，终于找到了问题所在。接下来就记录一下这个问题及其解决的方法。")]),e._v(" "),a("h2",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),a("p",[e._v("其实这个问题主要涉及到vue生命周期，对vue生命周期理解不够深刻的同学可以去官网学习一下："),a("a",{attrs:{href:"https://vuejs.org/v2/api/#Options-Lifecycle-Hooks",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://vuejs.org/v2/api/#Options-Lifecycle-Hooks"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("解决这个问题的关键就在于对keep-alive的理解和"),a("code",[e._v("activated钩子函数的使用。")])]),e._v(" "),a("p",[e._v("当在项目中引入keep-alive的时候，页面第一次进入，钩子函数的触发顺序created -> mounted -> activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。")]),e._v(" "),a("p",[e._v("我们知道 keep-alive 之后，页面模板第一次初始化解析变成HTML片段后，再次进入就不再重新解析而是读取内存中的数据，即，只有当数据变化时，才使用VirtualDOM进行diff更新。故，页面进入的数据获取应该在activated中也放一份。数据加载完毕手动操作DOM的部分也应该在activated中执行才会生效。")]),e._v(" "),a("p",[e._v("所以，应该activated中留一份数据获取的代码，或者不要created部分，直接将created中的代码转移到activated中。")]),e._v(" "),a("h2",{attrs:{id:"html结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html结构"}},[e._v("#")]),e._v(" html结构")]),e._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"1","data-src":"/vuepress-blog/img/post/2021-12-26-03/1.webp",loading:"lazy"}})]),e._v(" "),a("h2",{attrs:{id:"js部分-vue生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js部分-vue生命周期"}},[e._v("#")]),e._v(" js部分--vue生命周期")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("    beforeCreate () {\n\n      console.log('在实例初始化之前调用')\n\n    }\n\n    created () {\n\n      console.log('在实例初始化之后调用，经常用于操作数据，发起ajax请求')\n\n    }\n\n    beforeMount () {\n\n      console.log('在挂载开始之前被调用，如果是在服务器端渲染时不被调用；在这个函数里，无法获取元素')\n\n    }\n\n \n\n    mounted () {\n\n      console.log('在挂载后被调用，也不能在服务器端渲染时被调用；这个函数里，是可以获取元素，并进行操作的')\n\n    }\n\n    beforeUpdate () {\n\n      console.log('视图层数据更新前调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM')\n\n    }\n\n    updated () {\n\n      console.log('视图层数据更新后调用')\n\n    }\n\n    beforeDestroy () {\n\n      console.log('实例销毁之前调用，在被销毁的组件中进行调用;有一些操作，会在实例已经销毁的时候还在运行，这时候为了性能考虑，就在这里结束哪些操作')\n\n    }\n\n    destroyed () {\n\n      console.log('实例销毁后调用。')\n\n    }\n\n    // activated和deactivated配合keep-alive标签使用!\n\n    activated () {\n\n      console.log('实例被激活时使用，用于重复激活一个实例的时候')\n\n    }\n\n    deactivated () {\n\n      console.log('实例没有被激活时')\n\n    }\n")])])]),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[e._v("keep-alive是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM；导致在组件mounted钩子中调用的刷新页面内容时，这个钩子没有被调用。")]),e._v(" "),a("p",[e._v("故：使用Vue组件切换过程，执行钩子activated(keep-alive组件激活时调用)，而不是挂载钩子mounted。")])])}),[],!1,null,null,null);t.default=s.exports}}]);