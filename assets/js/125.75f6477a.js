(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{513:function(t,e,n){"use strict";n.r(e);var a=n(1),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("blockquote",[n("p",[t._v("本文转载自："),n("a",{attrs:{href:"https://developers.weixin.qq.com/community/develop/article/doc/000624abcdc9f8896f9bbb7b556413",target:"_blank",rel:"noopener noreferrer"}},[t._v("小程序粘性布局组件实现"),n("OutboundLink")],1)])]),t._v(" "),n("p"),n("div",{staticClass:"table-of-contents"},[n("ul",[n("li",[n("a",{attrs:{href:"#一、前言"}},[t._v("一、前言")])]),n("li",[n("a",{attrs:{href:"#二、demo演示"}},[t._v("二、demo演示")])]),n("li",[n("a",{attrs:{href:"#三、代码演示"}},[t._v("三、代码演示")]),n("ul",[n("li",[n("a",{attrs:{href:"#_3-1-页面代码"}},[t._v("3.1 页面代码")])]),n("li",[n("a",{attrs:{href:"#页面js"}},[t._v("页面js")])]),n("li",[n("a",{attrs:{href:"#_3-2-组件代码"}},[t._v("3.2 组件代码")])])])]),n("li",[n("a",{attrs:{href:"#总结"}},[t._v("总结")])])])]),n("p"),t._v(" "),n("h2",{attrs:{id:"一、前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、前言"}},[t._v("#")]),t._v(" 一、前言")]),t._v(" "),n("p",[t._v("开发中，我们经常会遇需要让组件在屏幕范围内时，按照正常布局排列，而组件滚出屏幕范围时，让其始终固定在屏幕顶部的情况，也就是常说的粘性布局。今天我们就一起用小程序来实现一个适用于不同场景下的粘性布局组件。")]),t._v(" "),n("h2",{attrs:{id:"二、demo演示"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、demo演示"}},[t._v("#")]),t._v(" 二、demo演示")]),t._v(" "),n("p",[t._v("如图，实现的组件主要适用于以下几种场景：")]),t._v(" "),n("ol",[n("li",[t._v("吸顶页面最上方；")]),t._v(" "),n("li",[t._v("吸顶与页面有固定距离的位置；")]),t._v(" "),n("li",[t._v("在指定容器内吸顶；")]),t._v(" "),n("li",[t._v("嵌套在scroll-view中吸顶。\n"),n("img",{staticClass:"lazy",attrs:{alt:"0","data-src":"/vuepress-blog/img/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%B2%98%E6%80%A7%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/0.gif",loading:"lazy"}})])]),t._v(" "),n("h2",{attrs:{id:"三、代码演示"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、代码演示"}},[t._v("#")]),t._v(" 三、代码演示")]),t._v(" "),n("p",[t._v("其中，粘性组件通过"),n("weimob-sticky"),t._v("调用，参数信息用法如下：")],1),t._v(" "),n("p",[t._v("滚动时触发scroll函数，其中isFixed为是否吸顶，scrollTop为距离顶部的位置。详细代码如下。")]),t._v(" "),n("h3",{attrs:{id:"_3-1-页面代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-页面代码"}},[t._v("#")]),t._v(" 3.1 页面代码")]),t._v(" "),n("h4",{attrs:{id:"_3-1-1-基础用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-基础用法"}},[t._v("#")]),t._v(" 3.1.1 基础用法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<view class="weimob-block">\n  <view class="weimob-title">基础用法</view>\n  <view class="weimob-body">\n    <weimob-sticky>\n    \x3c!-- 需要粘性的部分 --\x3e\n      <button class="margin-left-base" size="mini">\n        基础用法\n      </button>\n    </weimob-sticky>\n  </view>\n</view>\n')])])]),n("h4",{attrs:{id:"_3-1-2-吸顶距离"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-吸顶距离"}},[t._v("#")]),t._v(" 3.1.2 吸顶距离")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<view class="weimob-block">\n  <view class="weimob-title">吸顶距离</view>\n  <view class="weimob-body">\n  \x3c!-- 吸顶时与顶部的距离，单位px --\x3e\n    <weimob-sticky offset-top="{{ 50 }}">\n    \x3c!-- 需要粘性的部分 --\x3e\n      <button class="margin-left-top" type="primary" size="mini">\n        吸顶距离\n      </button>\n    </weimob-sticky>\n  </view>\n</view>\n')])])]),n("h4",{attrs:{id:"_3-1-3-指定容器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-3-指定容器"}},[t._v("#")]),t._v(" 3.1.3 指定容器")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<view class="weimob-block">\n  <view class="weimob-title">指定容器</view>\n  <view class="weimob-body">\n  \x3c!-- 这里需要固定高度 --\x3e\n    <view id="container" style="height: 300rpx;background-color: #fff">\n      <weimob-sticky container="{{ container }}">\n        <button size="mini" class="margin-left-special">\n          指定容器\n        </button>\n      </weimob-sticky>\n    </view>\n  </view>\n</view>\n')])])]),n("h4",{attrs:{id:"_3-1-4-嵌套在scroll-view使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-4-嵌套在scroll-view使用"}},[t._v("#")]),t._v(" 3.1.4 嵌套在scroll-view使用")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<view class="weimob-block">\n  <view class="weimob-title">嵌套在 scroll-view 内使用</view>\n  \x3c!-- 这里需要固定高度，scroll-view里的元素高度需要大于其高度 --\x3e\n  <scroll-view\n\t\tbind:scroll="onScroll"\n\t\tscroll-y\n\t\tid="scroller"\n\t\tstyle="height: 400rpx; background-color: #fff;margin-top: 40rpx;"\n\t>\n\t\t<view style="height: 800rpx">\n\t\t\t<weimob-sticky\n\t\t\t\tscroll-top="{{ scrollTop }}"\n\t\t\t\toffset-top="{{ offsetTop }}"\n\t\t\t>\n\t\t\t\t<button size="mini" class="margin-left-scoll">\n\t\t\t\t\t嵌套在 scroll-view 内\n\t\t\t\t</button>\n\t\t\t</weimob-sticky>\n\t\t</view>\n\t</scroll-view>\n</view>\n')])])]),n("h3",{attrs:{id:"页面js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#页面js"}},[t._v("#")]),t._v(" 页面js")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Page({\n  data: {\n    container: null, //一个函数，返回容器对应的 NodesRef 节点\n    scrollTop: 60, // 当前滚动区域的滚动位置，非null时会禁用页面滚动事件的监听\n    offsetTop: 0  // 吸顶时与顶部的距离，单位px\n  },\n  \n  onReady() {\n  // 页面渲染完，获取节点信息\n    this.setData({\n      container: () => wx.createSelectorQuery().select('#container'),\n    });\n  },\n\n  onScroll(event) {\n   // 容器滚动时获取节点信息\n    wx.createSelectorQuery()\n      .select('#scroller')\n      .boundingClientRect((res) => {\n        this.setData({\n          scrollTop: event.detail.scrollTop,\n          offsetTop: res.top,\n        });\n      })\n      .exec();\n  }\n});\n")])])]),n("h3",{attrs:{id:"_3-2-组件代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-组件代码"}},[t._v("#")]),t._v(" 3.2 组件代码")]),t._v(" "),n("h4",{attrs:{id:"组件wxml"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组件wxml"}},[t._v("#")]),t._v(" 组件wxml")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<wxs src="./index.wxs" module="computed" />\n\n<view\n  class="weimob-sticky"\n  style="{{ computed.containerStyle({ fixed, height, zIndex }) }}"\n>\n  <view\n    class="{{ fixed ? \'weimob-sticky-wrap--fixed\' : \'\'}}"\n    style="{{ computed.wrapStyle({ fixed, offsetTop, transform, zIndex }) }}"\n  >\n    <slot />\n  </view>\n</view>\n')])])]),n("h4",{attrs:{id:"组件wxs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组件wxs"}},[t._v("#")]),t._v(" 组件wxs")]),t._v(" "),n("p",[t._v("这里使用使用小程序的wxs对吸顶元素的transform,top,height,z-index元素进行实时渲染，ios设备在滚动监听时性能会优于在js 2-20倍，androd设备效率暂无差异。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function wrapStyle(data) {\n  var style = \"\";\n\n\tif (data.transform) {\n\t\tstyle += 'transform: translate3d(0, ' + data.transform + 'px, 0);'\n\t}\n\n\tif (data.fixed) {\n    style += 'top: ' + data.offsetTop + 'px;'\n\t}\n\n\tif (data.zIndex) {\n\t\tstyle += 'z-index: ' + data.zIndex + ';'\n\t}\n\n\treturn style;\n}\n\nfunction containerStyle(data) {\n  var style = \"\";\n\n\tif (data.fixed) {\n    style += 'height: ' + data.height + 'px;'\n\t}\n\n\tif (data.zIndex) {\n\t\tstyle += 'z-index: ' + data.zIndex + ';'\n\t}\n\n\treturn style;\n}\n\nmodule.exports = {\n  wrapStyle: wrapStyle,\n  containerStyle: containerStyle\n}\n")])])]),n("h4",{attrs:{id:"组件js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组件js"}},[t._v("#")]),t._v(" 组件js")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('import pageScrollMixin from "./page-scroll";\nconst ROOT_ELEMENT = ".weimob-sticky";\n\nComponent({\n  options: {\n\t\tmultipleSlots: true\n\t},\n  properties: {\n    zIndex: {\n      type: Number,\n      value: 99\n    },\n    offsetTop: {\n      type: Number,\n      value: 0,\n      observer: "onScroll"\n    },\n    disabled: {\n      type: Boolean,\n      observer: "onScroll"\n    },\n    container: {\n      type: null,\n      observer: "onScroll"\n    },\n    scrollTop: {\n      type: null,\n      observer(val) {\n        this.onScroll({\n          scrollTop: val\n        });\n      }\n\n    }\n  },\n  data: {\n    height: 0,\n    fixed: false,\n    transform: 0\n  },\n  behaviors: [pageScrollMixin(function pageScrollMixinCallback(event) {\n    // 非null时会禁用页面滚动事件的监听\n    if (this.data.scrollTop != null) {\n      return;\n    }\n\n    this.onScroll(event);\n  })],\n  lifetimes: {\n    attached() {\n      this.onScroll();\n    }\n\n  },\n  methods: {\n    onScroll({\n      scrollTop\n    } = {}) {\n      const {\n        container,\n        offsetTop,\n        disabled\n      } = this.data;\n\n      if (disabled) {\n        this.setDataAfterDiff({\n          fixed: false,\n          transform: 0\n        });\n        return;\n      }\n\n      this.scrollTop = scrollTop || this.scrollTop;\n\n      if (typeof container === "function") {\n        // 情况一：指定容器下时，吸顶距离+吸顶元素高度>容器高度+容器距顶部距离,随页面滚动；\n        // 情况二：指定容器下时，吸顶距离>吸顶元素高度,元素固定；\n        // 情况三：元素初始化。\n        \n\n        // this.getRect获取节点ROOT_ELEMENT相对于显示区域的top,height等信息，通过root获取\n        // this.getContainerRect获取父容器相对于显示区域的top,height等信息，通过container获取\n\n        Promise.all([this.getRect(ROOT_ELEMENT), this.getContainerRect()]).then( \n        ([root, container]) => {\n          if (offsetTop + root.height > container.height + container.top) {\n            this.setDataAfterDiff({\n              fixed: false,\n              transform: container.height - root.height\n            });\n          } else if (offsetTop >= root.top) {\n            this.setDataAfterDiff({\n              fixed: true,\n              height: root.height,\n              transform: 0\n            });\n          } else {\n            this.setDataAfterDiff({\n              fixed: false,\n              transform: 0\n            });\n          }\n        });\n        return;\n      }else{\n        this.getRect(ROOT_ELEMENT).then(root => {\n          // 吸顶时与顶部的距离小于可视区域的top距离时，随着滚动条滚动，否则吸顶\n          if (offsetTop >= root.top) {\n            this.setDataAfterDiff({\n              fixed: true,\n              height: root.height\n            });\n            this.transform = 0;\n          } else {\n            this.setDataAfterDiff({\n              fixed: false\n            });\n          }\n  \n          return Promise.resolve();\n        });\n      }\n    },\n\n    setDataAfterDiff(data) {\n      // 比较数据是否与上次相同，不同则触发父组件scroll事件更新isFixed，scrollTop。\n      wx.nextTick(() => {\n        const diff = Object.keys(data).reduce((prev, key) => {\n          const prevCopy = prev;\n\n          if (data[key] !== this.data[key]) {\n            prevCopy[key] = data[key];\n          }\n\n          return prevCopy;\n        }, {});\n        this.setData(diff);\n        this.triggerEvent("scroll", {\n          scrollTop: this.scrollTop,\n          isFixed: data.fixed || this.data.fixed\n        });\n      });\n    },\n\n    getContainerRect() {\n      const nodesRef = this.data.container();\n      return new Promise(resolve => nodesRef.boundingClientRect(resolve).exec());\n    },\n\n    getRect(selector) {\n      return new Promise(resolve => {\n        wx.createSelectorQuery().in(this).select(selector).boundingClientRect(rect => {\n          resolve(rect);\n        }).exec();\n      });\n    }\n\n  }\n});\n')])])]),n("h4",{attrs:{id:"page-scroll-js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#page-scroll-js"}},[t._v("#")]),t._v(" page-scroll.js")]),t._v(" "),n("p",[t._v("滚动事件在页面进入和离开时共享的pageScrollMixin函数。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function getCurrentPage() {\n  const pages = getCurrentPages();\n  return pages[pages.length - 1] || {};\n}\n\nfunction onPageScroll(event) {\n  const {\n    weimobPageScroller = []\n  } = getCurrentPage();\n  weimobPageScroller.forEach(scroller => {\n    if (typeof scroller === "function" && event) {\n      // @ts-ignore\n      scroller(event);\n    }\n  });\n}\n\nconst pageScrollMixin = scroller => Behavior({\n  attached() {\n    const page = getCurrentPage();\n\n    if (Array.isArray(page.weimobPageScroller)) {\n      page.weimobPageScroller.push(scroller.bind(this));\n    } else {\n      page.weimobPageScroller = typeof page.onPageScroll === "function" ? [page.onPageScroll.bind(page), scroller.bind(this)] : [scroller.bind(this)];\n    }\n\n    page.onPageScroll = onPageScroll;\n  },\n\n  detached() {\n    const page = getCurrentPage();\n    page.weimobPageScroller = (page.weimobPageScroller || []).filter(item => item !== scroller);\n  }\n\n});\n\nexport default pageScrollMixin;\n')])])]),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),n("p",[t._v("最后，我将上述代码放在了代码片段中供大家使用了解，https://developers.weixin.qq.com/s/qiym3wmr7znx，希望能够帮到小伙伴们，欢迎评论区建议或指教哦~")])])}),[],!1,null,null,null);e.default=s.exports}}]);